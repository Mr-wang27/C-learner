//程序以保留每3个字符中的第一个字符的方式压缩一个文件，并把压缩后的文件输出到第二个文件
//在命令行里输入代操作的文件的名字时，要将文件的后缀名也输入进去。并且在命令行中输入前，要将文件目录指定到该文件目录下，并且可执行文件和待操作文件均在这一目录下，否则将找不到待操作文件目录
#include<stdio.h>//提供I/O函数原型
#include<string.h>//提供字符串操作函数
#include<stdlib.h>//提供动态内存分配函数，提供exit()函数和EXIT_SUCCESS(0)(表明程序正常结束)，EXIT_FAILURE(-1)(表明程序异常中止)的宏定义
//exit()函数用于关闭所有打开的文件并结束程序。exit()函数的参数被传递给一些操作系统，包括UNIX，Liunx，Windos，MS_DOS.通常惯例的做法是：正常结束程序传递参数0，一场结束程序传递参数非零值，不同的参数退出值可用于区分程序失败的不同原因。但是这里又有一个问题就是不是所有的操作系统都支持识别相同的范围内的值，所以C标准规定了一个最小的限制范围：EXIT_SUCCESS(0),EXIT_FAILURE(-1)
//exit()函数还可以用于最初调用的main()函数中使用，其作用和return一样，均能表示程序正常结束。即：exit(0)与return 0作用一样，但是这里强调的是最初的调用，如果涉及递归那么这两个语句的作用就是不同的，return 0：会将控制权交给上一级递归，直到达到最初的main()，而exit仍然会使程序中止
#define LEM 40
int main(int argc,char**argv)//这里char**argv与char*argv[]一样     //命令行参数：第一个参数为argc(arguement count:参数计数)：累计在命令行获取的参数的数量，至少为1，因为第一个argv[0]会存储程序名
//第二个参数为argv(arguement value:参数值)：第一个参数会存储程序名，其会将获取的字符串常量存储在静态存储区，然后将这个常量的地址存储在指针数组argv中，系统以空格表示一个字符串常量的开始和结束，许多系统允许用双引号将含有空格的字符串括起来表示一个字符串常量
{
    char ch;
    FILE*fp_in;//声明一个文件指针，        //输入的文件指针，指针指向指定的文件
    FILE*fp_out;//声明一个文件指针          //输出的文件指针
    //这里要说明一下文件指针这个东西。文件指针是定义在stdio.h中的一个派生类型。文件指针并不指向实际的文件，它指向的是文件信息的数据对象(这是一个C结构，在第十四章介绍)，这个数据对象中包含操作文件的I/O函数所用的缓冲区的信息。(因为标准I/O使用缓冲区，所以他不仅要知道缓冲区的位置，还要知道缓冲区被填充的程度以及要操作那个文件。标准I/O函数根据这些信息在必要的时候决定再次填充或清空缓冲区)
    //注意！！这里声明了两个文件指针。      //程序都是单独打开和关闭每个文件的
                                        //同时打开的文件数量是有限的。这个限制取决于系统和实现。范围一般是10~·20
                                        //相同的文件指针可以处理不同的文件，前提是这些文件不需要同时打开。理解一下，其实就是文件指针也是一个指针变量，既然是指针变量，那么就可以通过赋值，将其指向不同的数据对象(结构，文件的数据对象)。
    int i_count=0;//用于计数是否达到3的倍数
    char name[LEM];//用于存储输出文件的名字
    if(argc<2){//检查命令行参数
        fprintf(stderr,"Usaeg: %s filename\n",argv[0]);//这里简单介绍一下fprintf()函数，该函数第一个参数为文件指针，后面其他的参数与printf一样，用法也一样，只是fprintf函数第一个参数(文件指针)用于指定待处理的文件
        exit(EXIT_FAILURE);//程序异常中止       //这里在介绍三个标准文件，这三个标准文件在允许c程序是都会被自动打开，在stdio.h中把这个三个自动文件和这三个文件指针相关联(即这三个文件指针分别指向这三个标准文件)：stdin(标准输入)，stdout(标准输出)，stderr(标准错误)。记忆：标准：standard，输入：input，输出：output，错误：error
    }//截至此处，命令行参数正确获取，开始设置输入，即打开文件
    if((fp_in=fopen(argv[1],"r"))==NULL){//这里介绍一下fopen函数。函数原型为FILE* fopen(const char*,"");第一个参数为指定待打开文件的名称，为一个字符串，第二个参数(也是一个字符串)为指定打开的文件模式。如果打开文件失败，会返回NULL。要记忆文件打开的模式表示的字符串分别是那些
        fprintf(stderr,"I could not open the file \"%s\"\n",argv[1]);//\"输出转义字符双引号
        exit(EXIT_FAILURE);
    }//检测文件是否被成功打开在正式的程序，是很重要的，因为有些系统不允许在后缀名后添加后缀，这将是不正确的文件格式，所以就会打开失败
    //下面将设置输出文件名的格式，设置完成后再打开该文件设置输出
    strncpy(name,argv[1],LEM-5);//字符串赋值函数，第三个参数表示赋值的最大字符数，-5的目的是为了空出5个空间存储".red\0"。这里我们将压缩后的文件在其名字后加上.red表示(red：reduce动词：减少，缩小)
    name[LEM-5]='\0';//这里也是一个编程的小技巧，这里将name[35]设置为空字符，是为了防止文件名过长，导致再文件名后拼接.red\0的时候空间不够，导致拼接失败。所以这里将name[35]设置为\0，起到一个以防万一的作用
    strcat(name,".red");//字符串拼接函数
    if((fp_out=fopen(name,"w"))==NULL){//以文件写模式打开文件，如果存在给文件，将会打开该文件并将其长度截为0，目的是为了使程序在一个空白的文件中进行操作，如果不存在给文件将会创建给文件
        fprintf(stderr,"Can not creat output file.\n");//这里补充一下就是关于这个标准文件：stderr，这里使用fprintf函数的原因是，第一个待处理参数是stderr，其通常使用的设备是显示器，所以使用这个fprintf函数，他会将错误信息输出至显示器，如果使用重定向，那么错误信息会被输出到文件中去，我们需要打开文件才能看到错误信息
        exit(3);//
    }//输出文件设置完毕,下面开始压缩
    while((ch=getc(fp_in))!=EOF){//这里介绍一下getc和putc函数。getc函数原型：int getc(FILE*_file),参数文件指针，副作用是从指定的文件获取一个字符putc的函数原型：int putc(char _ch,FILE* _file);第一个参数为待写入的字符，第二个参数为文件指针，待操作的文件。作用将字符写入指定的文件.getc读取到文件末尾或者读取错误是返回EOF(end of file)
    //getchar和putchar分别是通过getc和putc和stdin，stdout定义的。eg：getchar()=getc(stdin),putchar()=putc(char,stdout);
    //这里我们在读取文件前先对文件进行获取一个字符，然后紧接着马上进行检测是为了避免读到空文件：使用后for，while入口检测循环，在进入玄幻前先尝试获取
        if(i_count++ % 3==0)
        putc(ch,fp_out);    
    }//收尾工作，关闭打开的文件
    if(fclose(fp_in)||fclose(fp_out))//这里介绍一下fclose函数：fcolse函数原型：int fclose(FILE *);关闭文件指针指定的文件，必要时刷新缓冲区。若成功关关闭，fclose返回0，否则返回EOF(-1).
    fprintf(stderr,"Error in closing files.\n");//这里其实就是在坚持是否关闭文件成功        //在比较正式的文件中，应该检测文件是否关闭成功，因为如果磁盘已满，或移动硬盘被移除或出现I/O错误，都会导致调用fclose函数失败

    getchar();
    getchar();
    return 0;
}
//在程序的最后补充说明一下文件模式和模式字符串等内容
//首先是文件：文件通常是在磁盘或固态硬盘上一段已命名的存储区
//其次C提供两种文件模式：文本模式和二进制模式。以文本模式下C程序所见的内容和实际内容并不相同，因为程序在读写文件是均会把本地环境下的行末尾和文件末尾映射为C模式(C模式的行末尾：\n，C模式的文件末尾：Ctrl+z)。而二进制模式：成必须可以访问文件的每个字节。以二进制读写文本文件时，不会发生映射
//补充一点:重定向是将文件视为标准输出和标准输入
//FILE*fopen(const char*,""):第一个参数为带打开的文件的名称，是一个字符串，第二个参数(也是一个字符串)为指定待打开文件的模式
//这里结束fopen的第二个参数：模式字符串：
//"r":read:以读模式打开文件     "w":write:以写模式打开文件，把现有文件的长度截为0，如果文件不存在，这创建一个新文件
//"a":add:以写模式打开文件，在现有文件末尾添加内容，不存在文件则创建新的文件        "a+":以更新模式打开文件，可以都整个文件，但是只能在文件末尾添加新的内容。其他同"a"
//"r+":以更新模式打开文件(即可以读写文件)；     "w+":以更新模式打开文件，其他同"w"
//上面的都是以文本模式打开文件：即"r":以文本读模式打开文件
//在其后面加上字母b，则表示以二进制模式打开文件，其他内容均同上："rb":二进制读模式......"r+b"于"rb++"相同，表示二进制更新模式打开文件。其他雷士类似
//在其后面加上字母x，这是C11新增的一种模式。但是其只可以在写模式或者更新模式后面加上字母x，可以在文本和二进制的写或更新模式后面加上字母x。
//eg："wx"="w+x":       "wbx"="wb+x"="w+bx"
//这种模式有两个新增的特性：特性一：如果以传统的写模式打开一个现有文件，fopen()会将该文件的长度截为0，这样就丢失源文件的内容，而带x的写模式，即使fopen()操作失败了，也不会删除源文件的内容
//                        特性二：若环境允许，x模式的独占特性，会使得其他程序或线程无法访问正在被打开的文件
//这里有一个警告!!：如果在使用任何一种"w"模式(不带x)，打开一个现有文件，该文件的内容均会被删除，以便程序操作一个空白文件
//                 然而，使用带x的任何一种模式均无法打开一个现有文件+
